---
title: Full Account Data
description: Retrieve comprehensive account information including balances, tokens, NFTs, staking positions, labels, and risk scores. Complete blockchain profile in a single request.
icon: user-circle
---

import { Endpoint, Request } from '@mintlify/components';

## Get Complete Account Data

<Endpoint method="GET" path="/v1/accounts/:id" />

Retrieve all available data for a NEAR account in one comprehensive response. This endpoint aggregates native balance, token holdings, NFT ownership, staking positions, account labels, and forensic risk scoring.

<Info>
  This endpoint provides a complete account snapshot. For specific data types only, use the dedicated endpoints (`/balance`, `/staking`, `/burrow`).
</Info>

### Path Parameters

<ParamField path="id" type="string" required>
  The NEAR account ID to query. Can be a named account or implicit account.
  
  **Examples:**
  - `example.near` - Named account
  - `alice.near` - User account
  - `wrap.near` - Token contract
  - `pool.near` - Validator pool
  - `98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de` - Implicit account
</ParamField>

### Making Requests

<Tabs>
  <Tab title="cURL">
    **Get complete account data:**
    ```bash
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/accounts/example.near"
    ```

    **Query implicit account:**
    ```bash
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/accounts/98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de"
    ```

    **Check validator pool:**
    ```bash
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/accounts/pool.near"
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    // Helper function to convert yoctoNEAR to NEAR
    const yoctoToNear = (yoctoAmount) => {
      return (BigInt(yoctoAmount) / BigInt(10**24)).toString() + 
             '.' + 
             (BigInt(yoctoAmount) % BigInt(10**24)).toString().padStart(24, '0').slice(0, 6);
    };

    // Get complete account data
    const getAccountData = async (accountId) => {
      const response = await fetch(
        `https://api.shadowcorp.dev/v1/accounts/${accountId}`,
        {
          headers: {
            'X-API-Key': 'YOUR_KEY'
          }
        }
      );
      return await response.json();
    };

    // Display account summary with formatted balances
    const displayAccountSummary = async (accountId) => {
      const data = await getAccountData(accountId);
      
      const nearBalance = yoctoToNear(data.state.amount);
      const lockedBalance = yoctoToNear(data.state.locked);
      const totalStaked = yoctoToNear(data.staking.total_staked);
      
      console.log(`Account: ${data.account_id}`);
      console.log(`Balance: ${nearBalance} NEAR`);
      console.log(`Locked: ${lockedBalance} NEAR`);
      console.log(`Staked: ${totalStaked} NEAR`);
      console.log(`Tokens: ${data.tokens?.length || 0}`);
      console.log(`NFTs: ${data.nfts?.length || 0}`);
      console.log(`Transactions: ${data.transaction_count}`);
      console.log(`Risk Score: ${data.risk_score || 'N/A'}`);
      
      if (data.labels?.length > 0) {
        console.log(`Labels: ${data.labels.join(', ')}`);
      }
      
      return data;
    };

    // Compare multiple accounts
    const compareAccounts = async (accountIds) => {
      const accounts = await Promise.all(
        accountIds.map(id => getAccountData(id))
      );
      
      return accounts.map(acc => ({
        id: acc.account_id,
        balance: yoctoToNear(acc.state.amount),
        staked: yoctoToNear(acc.staking.total_staked),
        tokenCount: acc.tokens?.length || 0,
        nftCount: acc.nfts?.length || 0,
        transactions: acc.transaction_count,
        riskScore: acc.risk_score
      }));
    };

    // Usage
    const account = await displayAccountSummary('therealmagyar.near');
    
    const comparison = await compareAccounts([
      'alice.near',
      'bob.near',
      'charlie.near'
    ]);
    ```
  </Tab>
  
  <Tab title="Python">
    ```python
    import requests
    from typing import Dict, List, Optional
    from decimal import Decimal

    class AccountDataAPI:
        def __init__(self, api_key: str):
            self.base_url = 'https://api.shadowcorp.dev'
            self.headers = {'X-API-Key': api_key}
        
        @staticmethod
        def yocto_to_near(yocto_amount: str) -> str:
            """Convert yoctoNEAR to NEAR"""
            amount = Decimal(yocto_amount) / Decimal(10**24)
            return f"{amount:.6f}"
        
        def get_account_data(self, account_id: str) -> Dict:
            """Get complete account data"""
            response = requests.get(
                f'{self.base_url}/v1/accounts/{account_id}',
                headers=self.headers
            )
            response.raise_for_status()
            return response.json()
        
        def get_account_summary(self, account_id: str) -> Dict:
            """Get formatted account summary"""
            data = self.get_account_data(account_id)
            
            return {
                'account_id': data.get('account_id'),
                'balance': self.yocto_to_near(data.get('state', {}).get('amount', '0')),
                'locked': self.yocto_to_near(data.get('state', {}).get('locked', '0')),
                'staked': self.yocto_to_near(data.get('staking', {}).get('total_staked', '0')),
                'token_count': len(data.get('tokens', [])),
                'nft_count': len(data.get('nfts', [])),
                'staking_pools': len(data.get('staking', {}).get('pools', [])),
                'transaction_count': data.get('transaction_count', 0),
                'labels': data.get('labels', []),
                'risk_score': data.get('risk_score'),
                'cluster': data.get('cluster')
            }
        
        def get_token_holdings(self, account_id: str) -> List[Dict]:
            """Extract just token holdings"""
            data = self.get_account_data(account_id)
            return data.get('tokens', [])
        
        def get_nft_holdings(self, account_id: str) -> List[Dict]:
            """Extract just NFT holdings"""
            data = self.get_account_data(account_id)
            return data.get('nfts', [])
        
        def get_staking_positions(self, account_id: str) -> List[Dict]:
            """Extract staking positions with NEAR amounts"""
            data = self.get_account_data(account_id)
            pools = data.get('staking', {}).get('pools', [])
            
            return [
                {
                    'pool_id': pool['pool_id'],
                    'amount': self.yocto_to_near(pool['amount']),
                    'amount_yocto': pool['amount']
                }
                for pool in pools
            ]
        
        def is_high_risk(self, account_id: str, threshold: int = 75) -> bool:
            """Check if account is high risk"""
            data = self.get_account_data(account_id)
            risk_score = data.get('risk_score')
            return risk_score is not None and risk_score >= threshold
        
        def compare_accounts(self, account_ids: List[str]) -> List[Dict]:
            """Compare multiple accounts"""
            return [
                self.get_account_summary(account_id)
                for account_id in account_ids
            ]

    # Usage
    api = AccountDataAPI('YOUR_KEY')
    
    # Get complete data
    account = api.get_account_data('therealmagyar.near')
    print(f"Account: {account['account_id']}")
    balance = api.yocto_to_near(account['state']['amount'])
    print(f"Balance: {balance} NEAR")
    
    # Get summary
    summary = api.get_account_summary('therealmagyar.near')
    print(f"Balance: {summary['balance']} NEAR")
    print(f"Staked: {summary['staked']} NEAR")
    print(f"Tokens: {summary['token_count']}")
    print(f"NFTs: {summary['nft_count']}")
    print(f"Transactions: {summary['transaction_count']}")
    
    # Check token holdings
    tokens = api.get_token_holdings('alice.near')
    for token in tokens:
        print(f"{token['symbol']}: {token['balance']}")
    
    # Check staking
    stakes = api.get_staking_positions('alice.near')
    for stake in stakes:
        print(f"{stake['pool_id']}: {stake['amount']} NEAR")
    
    # Risk assessment
    if api.is_high_risk('suspicious.near'):
        print("‚ö†Ô∏è  High risk account detected!")
    
    # Compare accounts
    comparison = api.compare_accounts([
        'alice.near',
        'bob.near',
        'charlie.near'
    ])
    ```
  </Tab>
  
  <Tab title="Go">
    ```go
    package main

    import (
        "encoding/json"
        "fmt"
        "net/http"
    )

    type AccountDataClient struct {
        BaseURL string
        APIKey  string
        Client  *http.Client
    }

    type Balance struct {
        Amount   string `json:"amount"`
        Currency string `json:"currency"`
    }

    type Token struct {
        ContractID string `json:"contract_id"`
        Balance    string `json:"balance"`
        Symbol     string `json:"symbol"`
        Decimals   int    `json:"decimals"`
    }

    type NFT struct {
        ContractID string `json:"contract_id"`
        TokenID    string `json:"token_id"`
    }

    type StakingPosition struct {
        PoolID string `json:"pool_id"`
        Amount string `json:"amount"`
    }

    type AccountData struct {
        AccountID string             `json:"account_id"`
        Balance   *Balance           `json:"balance"`
        Tokens    []Token            `json:"tokens"`
        NFTs      []NFT              `json:"nfts"`
        Staking   []StakingPosition  `json:"staking"`
        Labels    []string           `json:"labels"`
        RiskScore *int               `json:"risk_score"`
    }

    func NewAccountDataClient(apiKey string) *AccountDataClient {
        return &AccountDataClient{
            BaseURL: "https://api.shadowcorp.dev",
            APIKey:  apiKey,
            Client:  &http.Client{},
        }
    }

    func (c *AccountDataClient) GetAccountData(accountID string) (*AccountData, error) {
        reqURL := fmt.Sprintf("%s/v1/accounts/%s", c.BaseURL, accountID)
        
        req, err := http.NewRequest("GET", reqURL, nil)
        if err != nil {
            return nil, err
        }
        
        req.Header.Add("X-API-Key", c.APIKey)
        
        resp, err := c.Client.Do(req)
        if err != nil {
            return nil, err
        }
        defer resp.Body.Close()

        var data AccountData
        if err := json.NewDecoder(resp.Body).Decode(&data); err != nil {
            return nil, err
        }
        
        return &data, nil
    }

    func (c *AccountDataClient) GetAccountSummary(accountID string) (map[string]interface{}, error) {
        data, err := c.GetAccountData(accountID)
        if err != nil {
            return nil, err
        }
        
        balance := "0"
        if data.Balance != nil {
            balance = data.Balance.Amount
        }
        
        riskScore := "N/A"
        if data.RiskScore != nil {
            riskScore = fmt.Sprintf("%d", *data.RiskScore)
        }
        
        return map[string]interface{}{
            "account_id":    data.AccountID,
            "balance":       balance,
            "token_count":   len(data.Tokens),
            "nft_count":     len(data.NFTs),
            "staking_count": len(data.Staking),
            "labels":        data.Labels,
            "risk_score":    riskScore,
        }, nil
    }

    func (c *AccountDataClient) IsHighRisk(accountID string, threshold int) (bool, error) {
        data, err := c.GetAccountData(accountID)
        if err != nil {
            return false, err
        }
        
        if data.RiskScore == nil {
            return false, nil
        }
        
        return *data.RiskScore >= threshold, nil
    }

    func main() {
        client := NewAccountDataClient("YOUR_KEY")
        
        // Get complete account data
        account, err := client.GetAccountData("alice.near")
        if err != nil {
            panic(err)
        }
        
        fmt.Printf("Account: %s\n", account.AccountID)
        if account.Balance != nil {
            fmt.Printf("Balance: %s NEAR\n", account.Balance.Amount)
        }
        fmt.Printf("Tokens: %d\n", len(account.Tokens))
        fmt.Printf("NFTs: %d\n", len(account.NFTs))
        
        // Get summary
        summary, err := client.GetAccountSummary("alice.near")
        if err != nil {
            panic(err)
        }
        
        fmt.Printf("\nSummary: %+v\n", summary)
        
        // Risk check
        isHighRisk, err := client.IsHighRisk("suspicious.near", 75)
        if err != nil {
            panic(err)
        }
        
        if isHighRisk {
            fmt.Println("‚ö†Ô∏è  High risk account detected!")
        }
    }
    ```
  </Tab>
</Tabs>

### Response Format

<ResponseField name="account_id" type="string" required>
  The NEAR account identifier.
</ResponseField>

<ResponseField name="state" type="object" required>
  Account state information including balances and storage.
  
  <Expandable title="State Object">
    <ResponseField name="amount" type="string">
      Available balance in yoctoNEAR (10^-24 NEAR). Divide by 10^24 to get NEAR amount.
    </ResponseField>
    
    <ResponseField name="locked" type="string">
      Locked balance in yoctoNEAR (e.g., for storage staking).
    </ResponseField>
    
    <ResponseField name="storage_usage" type="integer">
      Storage used by this account in bytes.
    </ResponseField>
    
    <ResponseField name="code_hash" type="string">
      Hash of deployed contract code. "11111111111111111111111111111111" indicates no contract deployed.
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="transaction_count" type="integer">
  Total number of transactions involving this account.
</ResponseField>

<ResponseField name="tokens" type="array">
  Array of fungible token (FT) holdings.
  
  <Expandable title="Token Object">
    <ResponseField name="contract_id" type="string">
      Token contract address.
    </ResponseField>
    
    <ResponseField name="balance" type="string">
      Token balance (raw amount with decimals).
    </ResponseField>
    
    <ResponseField name="symbol" type="string">
      Token symbol (e.g., "USDT", "wNEAR").
    </ResponseField>
    
    <ResponseField name="decimals" type="integer">
      Number of decimal places for the token.
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="nfts" type="array">
  Array of owned NFTs.
  
  <Expandable title="NFT Object">
    <ResponseField name="contract_id" type="string">
      NFT collection contract address.
    </ResponseField>
    
    <ResponseField name="token_id" type="string">
      Unique identifier for the specific NFT.
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="staking" type="object">
  Staking information across validator pools.
  
  <Expandable title="Staking Object">
    <ResponseField name="pools" type="array">
      Array of validator pools where this account has staked funds.
      
      <Expandable title="Pool Object">
        <ResponseField name="pool_id" type="string">
          Validator pool account ID.
        </ResponseField>
        
        <ResponseField name="amount" type="string">
          Staked amount in yoctoNEAR.
        </ResponseField>
      </Expandable>
    </ResponseField>
    
    <ResponseField name="total_staked" type="string">
      Total amount staked across all pools in yoctoNEAR.
    </ResponseField>
    
    <ResponseField name="recent_events" type="array">
      Recent staking events (deposits, withdrawals, rewards).
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="labels" type="array">
  Array of account classification labels (e.g., "exchange", "contract", "dex").
</ResponseField>

<ResponseField name="risk_score" type="integer">
  Forensic risk score from 0-100. Higher scores indicate higher risk. Returns `null` if not calculated.
</ResponseField>

<ResponseField name="cluster" type="string">
  Account cluster identifier for forensic analysis. Returns `null` if not clustered.
</ResponseField>

### Success Response (200 OK)

**Regular User Account (therealmagyar.near):**
```json
{
  "account_id": "therealmagyar.near",
  "state": {
    "amount": "12817632130134446609948969",
    "locked": "0",
    "storage_usage": 182,
    "code_hash": "11111111111111111111111111111111"
  },
  "transaction_count": 25,
  "tokens": [],
  "nfts": [],
  "staking": {
    "pools": [],
    "total_staked": "0",
    "recent_events": []
  },
  "labels": [],
  "risk_score": null,
  "cluster": null
}
```

**Account with Token Holdings:**
```json
{
  "account_id": "alice.near",
  "state": {
    "amount": "125450000000000000000000000",
    "locked": "350000000000000000000000",
    "storage_usage": 2840,
    "code_hash": "11111111111111111111111111111111"
  },
  "transaction_count": 1547,
  "tokens": [
    {
      "contract_id": "usdt.tether-token.near",
      "balance": "500000000",
      "symbol": "USDT",
      "decimals": 6
    },
    {
      "contract_id": "wrap.near",
      "balance": "50250000000000000000000000",
      "symbol": "wNEAR",
      "decimals": 24
    }
  ],
  "nfts": [
    {
      "contract_id": "asac.near",
      "token_id": "1234"
    },
    {
      "contract_id": "paras-token-v2.near",
      "token_id": "5678:1"
    }
  ],
  "staking": {
    "pools": [
      {
        "pool_id": "pool.near",
        "amount": "1000000000000000000000000000"
      }
    ],
    "total_staked": "1000000000000000000000000000",
    "recent_events": [
      {
        "type": "stake",
        "amount": "1000000000000000000000000000",
        "timestamp": "2025-01-01T00:00:00Z"
      }
    ]
  },
  "labels": ["user", "nft-collector"],
  "risk_score": 15,
  "cluster": "cluster_abc123"
}
```

**New/Empty Account:**
```json
{
  "account_id": "new-account.near",
  "state": {
    "amount": "0",
    "locked": "0",
    "storage_usage": 182,
    "code_hash": "11111111111111111111111111111111"
  },
  "transaction_count": 0,
  "tokens": [],
  "nfts": [],
  "staking": {
    "pools": [],
    "total_staked": "0",
    "recent_events": []
  },
  "labels": [],
  "risk_score": null,
  "cluster": null
}
```

**High-Value Whale Account:**
```json
{
  "account_id": "whale.near",
  "state": {
    "amount": "50000000000000000000000000000",
    "locked": "5000000000000000000000000",
    "storage_usage": 5420,
    "code_hash": "11111111111111111111111111111111"
  },
  "transaction_count": 8942,
  "tokens": [
    {
      "contract_id": "usdt.tether-token.near",
      "balance": "100000000000",
      "symbol": "USDT",
      "decimals": 6
    }
  ],
  "nfts": [],
  "staking": {
    "pools": [
      {
        "pool_id": "pool.near",
        "amount": "25000000000000000000000000000"
      },
      {
        "pool_id": "validator1.near",
        "amount": "15000000000000000000000000000"
      }
    ],
    "total_staked": "40000000000000000000000000000",
    "recent_events": []
  },
  "labels": ["whale", "staker"],
  "risk_score": 5,
  "cluster": "whale_cluster_1"
}
```

<Check>
  A `200 OK` status code indicates the account data was retrieved successfully. Empty arrays indicate no holdings in that category.
</Check>

<Note>
  **Understanding yoctoNEAR:** All NEAR amounts are returned in yoctoNEAR (10^-24 NEAR). To convert to NEAR, divide by 1,000,000,000,000,000,000,000,000 (10^24).
  
  Example: `"12817632130134446609948969"` yoctoNEAR = `12.817632` NEAR
</Note>

## Understanding Account Data

<AccordionGroup>
  <Accordion title="Balance Types" icon="coins">
    NEAR accounts can hold multiple types of balances:
    
    **Native NEAR Balance:**
    - Used for gas fees
    - Transferable between accounts
    - Returned in human-readable format (e.g., "125.45 NEAR")
    
    **Token Balances:**
    - NEP-141 fungible tokens (FTs)
    - Each token has its own contract
    - Includes stablecoins (USDT, USDC), wrapped assets (wNEAR, wBTC), and project tokens
    
    **Staking Balance:**
    - NEAR locked in validator pools
    - Earns staking rewards
    - Subject to unstaking period (2-3 epochs)
    
    <Tip>
      Total account value = Native balance + Token balances (converted to NEAR) + Staking balance
    </Tip>
  </Accordion>
  
  <Accordion title="Account Labels" icon="tags">
    Labels classify accounts based on their behavior and purpose:
    
    **Common Labels:**
    - `exchange` - Centralized exchange wallets
    - `contract` - Smart contract accounts
    - `dex` - Decentralized exchange contracts
    - `user` - Regular user accounts
    - `whale` - High-value accounts
    - `nft-collector` - Active NFT traders
    - `staker` - Accounts with staking positions
    - `validator` - Validator pool accounts
    - `bot` - Automated trading accounts
    
    **Label Sources:**
    - On-chain behavior analysis
    - Transaction patterns
    - Known contract registries
    - Community reporting
    
    ```javascript
    function categorizeAccount(data) {
      const labels = data.labels || [];
      
      if (labels.includes('exchange')) {
        return 'Exchange Wallet';
      }
      if (labels.includes('contract')) {
        return 'Smart Contract';
      }
      if (labels.includes('whale')) {
        return 'High-Value Account';
      }
      return 'User Account';
    }
    ```
  </Accordion>
  
  <Accordion title="Risk Scoring" icon="shield-halved">
    Risk scores help identify potentially malicious or suspicious accounts:
    
    **Risk Score Ranges:**
    - `0-25` - Low risk (normal users)
    - `26-50` - Moderate risk (unusual patterns)
    - `51-75` - High risk (suspicious activity)
    - `76-100` - Critical risk (likely malicious)
    
    **Risk Factors:**
    - Recent account creation with high activity
    - Interaction with known scam contracts
    - Unusual transaction patterns
    - Association with flagged accounts
    - Abnormal token distribution patterns
    
    ```javascript
    function getRiskLevel(score) {
      if (score === null) return 'Unknown';
      if (score <= 25) return 'Low';
      if (score <= 50) return 'Moderate';
      if (score <= 75) return 'High';
      return 'Critical';
    }
    
    const account = await getAccountData('example.near');
    console.log(`Risk Level: ${getRiskLevel(account.risk_score)}`);
    ```
    
    <Warning>
      Risk scores are indicators, not definitive proof of malicious activity. Always investigate further before taking action.
    </Warning>
  </Accordion>
  
  <Accordion title="Token Holdings Analysis" icon="chart-pie">
    Analyze token portfolio composition:
    
    ```javascript
    function analyzeTokenPortfolio(tokens) {
      // Calculate total unique tokens
      const tokenCount = tokens.length;
      
      // Identify stablecoins
      const stablecoins = tokens.filter(t => 
        ['USDT', 'USDC', 'DAI', 'USDN'].includes(t.symbol)
      );
      
      // Find largest holdings
      const sorted = [...tokens].sort((a, b) => 
        parseFloat(b.balance) - parseFloat(a.balance)
      );
      
      return {
        totalTokens: tokenCount,
        stablecoinCount: stablecoins.length,
        largestHolding: sorted[0]?.contract_id,
        diversification: tokenCount > 5 ? 'High' : 'Low'
      };
    }
    
    const account = await getAccountData('trader.near');
    const analysis = analyzeTokenPortfolio(account.tokens);
    console.log(`Portfolio: ${analysis.totalTokens} tokens, ${analysis.diversification} diversification`);
    ```
  </Accordion>
</AccordionGroup>

## Use Cases

<CardGroup cols={2}>
  <Card title="Portfolio Tracking" icon="chart-line" color="#3b82f6">
    Build comprehensive portfolio dashboards with real-time balance updates.
  </Card>
  
  <Card title="Risk Assessment" icon="shield-check" color="#ef4444">
    Screen accounts for suspicious activity before allowing interactions.
  </Card>
  
  <Card title="User Profiling" icon="user-tag" color="#8b5cf6">
    Create detailed user profiles for personalized dApp experiences.
  </Card>
  
  <Card title="Whale Watching" icon="eye" color="#f59e0b">
    Monitor high-value accounts for market-moving transactions.
  </Card>
</CardGroup>

## Advanced Example: Account Analyzer

Here's a complete account analysis tool:

```javascript
class AccountAnalyzer {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.shadowcorp.dev';
    this.cache = new Map();
  }

  async getAccountData(accountId, useCache = true) {
    if (useCache && this.cache.has(accountId)) {
      console.log(`‚úÖ Using cached data for ${accountId}`);
      return this.cache.get(accountId);
    }

    console.log(`üîç Fetching data for ${accountId}...`);
    const response = await fetch(
      `${this.baseUrl}/v1/accounts/${accountId}`,
      {
        headers: { 'X-API-Key': this.apiKey }
      }
    );

    if (!response.ok) {
      throw new Error(`Failed to fetch ${accountId}: ${response.statusText}`);
    }

    const data = await response.json();
    this.cache.set(accountId, data);
    return data;
  }

  calculateTotalValue(account) {
    // Convert yoctoNEAR to NEAR
    const yoctoToNear = (yocto) => {
      return parseFloat(yocto) / 1e24;
    };
    
    // Native NEAR balance
    const nativeBalance = yoctoToNear(account.state?.amount || '0');
    
    // Locked balance
    const lockedBalance = yoctoToNear(account.state?.locked || '0');
    
    // Token count
    const tokenCount = account.tokens?.length || 0;
    
    // Staking balance
    const stakingBalance = yoctoToNear(account.staking?.total_staked || '0');

    return {
      native: nativeBalance,
      locked: lockedBalance,
      staking: stakingBalance,
      total: nativeBalance + stakingBalance,
      tokenCount,
      transactionCount: account.transaction_count || 0
    };
  }

  getRiskLevel(score) {
    if (score === null || score === undefined) return 'Unknown';
    if (score <= 25) return 'Low';
    if (score <= 50) return 'Moderate';
    if (score <= 75) return 'High';
    return 'Critical';
  }

  getAccountType(account) {
    const labels = account.labels || [];
    
    if (labels.includes('exchange')) return 'Exchange';
    if (labels.includes('contract')) return 'Contract';
    if (labels.includes('validator')) return 'Validator';
    if (labels.includes('whale')) return 'Whale';
    if (labels.includes('bot')) return 'Bot';
    return 'User';
  }

  async generateReport(accountId) {
    const account = await this.getAccountData(accountId);
    const value = this.calculateTotalValue(account);
    const riskLevel = this.getRiskLevel(account.risk_score);
    const accountType = this.getAccountType(account);

    console.log('\n' + '='.repeat(70));
    console.log(`Account Report: ${account.account_id}`);
    console.log('='.repeat(70));
    
    console.log(`\nüìä Overview:`);
    console.log(`  Type: ${accountType}`);
    console.log(`  Risk Level: ${riskLevel} (${account.risk_score ?? 'N/A'})`);
    if (account.labels?.length > 0) {
      console.log(`  Labels: ${account.labels.join(', ')}`);
    }

    console.log(`\nüí∞ Balances:`);
    console.log(`  Native NEAR: ${value.native.toFixed(6)} NEAR`);
    console.log(`  Locked: ${value.locked.toFixed(6)} NEAR`);
    console.log(`  Staked: ${value.staking.toFixed(6)} NEAR`);
    console.log(`  Total Value: ${value.total.toFixed(6)} NEAR`);

    console.log(`\nü™ô Holdings:`);
    console.log(`  Tokens: ${account.tokens?.length || 0}`);
    console.log(`  NFTs: ${account.nfts?.length || 0}`);
    console.log(`  Staking Pools: ${account.staking?.pools?.length || 0}`);
    console.log(`  Transactions: ${value.transactionCount}`);

    if (account.tokens?.length > 0) {
      console.log(`\nüíµ Top Token Holdings:`);
      account.tokens.slice(0, 5).forEach(token => {
        console.log(`  ${token.symbol}: ${token.balance}`);
      });
    }

    if (account.staking?.pools?.length > 0) {
      console.log(`\nüè¶ Staking Positions:`);
      account.staking.pools.forEach(stake => {
        const amount = parseFloat(stake.amount) / 1e24;
        console.log(`  ${stake.pool_id}: ${amount.toFixed(6)} NEAR`);
      });
    }

    console.log('='.repeat(70) + '\n');

    return account;
  }

  async compareAccounts(accountIds) {
    console.log(`üìä Comparing ${accountIds.length} accounts...\n`);
    
    const accounts = await Promise.all(
      accountIds.map(id => this.getAccountData(id))
    );

    const comparisons = accounts.map(acc => {
      const value = this.calculateTotalValue(acc);
      return {
        id: acc.account_id,
        type: this.getAccountType(acc),
        balance: value.native,
        staking: value.staking,
        tokens: acc.tokens?.length || 0,
        nfts: acc.nfts?.length || 0,
        risk: this.getRiskLevel(acc.risk_score)
      };
    });

    // Display comparison table
    console.log('Account Comparison:');
    console.log('‚îÄ'.repeat(100));
    console.log(
      'Account'.padEnd(25) + 
      'Type'.padEnd(12) + 
      'Balance'.padEnd(15) + 
      'Staking'.padEnd(15) + 
      'Tokens'.padEnd(10) + 
      'NFTs'.padEnd(10) + 
      'Risk'
    );
    console.log('‚îÄ'.repeat(100));

    comparisons.forEach(comp => {
      const id = comp.id.substring(0, 23);
      console.log(
        id.padEnd(25) +
        comp.type.padEnd(12) +
        `${comp.balance.toFixed(2)} NEAR`.padEnd(15) +
        `${comp.staking.toFixed(2)} NEAR`.padEnd(15) +
        comp.tokens.toString().padEnd(10) +
        comp.nfts.toString().padEnd(10) +
        comp.risk
      );
    });

    console.log('‚îÄ'.repeat(100) + '\n');

    return comparisons;
  }

  async findWhales(accountIds, minBalance = 10000) {
    console.log(`üêã Searching for whales (min ${minBalance} NEAR)...\n`);
    
    const accounts = await Promise.all(
      accountIds.map(id => this.getAccountData(id))
    );

    const whales = accounts
      .map(acc => ({
        id: acc.account_id,
        value: this.calculateTotalValue(acc)
      }))
      .filter(acc => acc.value.total >= minBalance)
      .sort((a, b) => b.value.total - a.value.total);

    whales.forEach((whale, index) => {
      console.log(
        `${index + 1}. ${whale.id}: ${whale.value.total.toFixed(2)} NEAR`
      );
    });

    console.log(`\nFound ${whales.length} whale accounts.\n`);
    return whales;
  }

  async screenForRisk(accountIds, maxRiskScore = 50) {
    console.log(`üõ°Ô∏è  Screening ${accountIds.length} accounts for risk...\n`);
    
    const accounts = await Promise.all(
      accountIds.map(id => this.getAccountData(id))
    );

    const flagged = accounts.filter(acc => 
      acc.risk_score !== null && acc.risk_score > maxRiskScore
    );

    if (flagged.length === 0) {
      console.log('‚úÖ All accounts passed risk screening.\n');
      return [];
    }

    console.log(`‚ö†Ô∏è  Found ${flagged.length} high-risk accounts:\n`);
    flagged.forEach(acc => {
      console.log(
        `  ${acc.account_id}: Risk Score ${acc.risk_score} (${this.getRiskLevel(acc.risk_score)})`
      );
      if (acc.labels?.length > 0) {
        console.log(`    Labels: ${acc.labels.join(', ')}`);
      }
    });
    console.log();

    return flagged;
  }
}

// Usage Examples
const analyzer = new AccountAnalyzer('YOUR_KEY');

// Generate detailed report
await analyzer.generateReport('alice.near');

// Compare multiple accounts
await analyzer.compareAccounts([
  'alice.near',
  'bob.near',
  'charlie.near'
]);

// Find whale accounts
await analyzer.findWhales([
  'alice.near',
  'bob.near',
  'whale1.near',
  'whale2.near'
], 50000);

// Screen for high-risk accounts
await analyzer.screenForRisk([
  'alice.near',
  'suspicious.near',
  'sketchy.near'
], 60);
```

## Portfolio Value Calculation

Calculate total portfolio value including token prices:

```javascript
// Helper to convert yoctoNEAR to NEAR
const yoctoToNear = (yocto) => parseFloat(yocto) / 1e24;

// Note: This example assumes you have a price oracle/API
async function calculatePortfolioValue(accountId, priceOracle) {
  const account = await fetch(
    `https://api.shadowcorp.dev/v1/accounts/${accountId}`,
    { headers: { 'X-API-Key': 'YOUR_KEY' } }
  ).then(r => r.json());

  // Native NEAR value
  const nearBalance = yoctoToNear(account.state?.amount || '0');
  const nearPrice = await priceOracle.getPrice('NEAR');
  const nearValue = nearBalance * nearPrice;

  // Locked balance (also in NEAR)
  const lockedBalance = yoctoToNear(account.state?.locked || '0');
  const lockedValue = lockedBalance * nearPrice;

  // Token values
  let tokenValue = 0;
  for (const token of account.tokens || []) {
    const price = await priceOracle.getPrice(token.contract_id);
    const balance = parseFloat(token.balance) / Math.pow(10, token.decimals);
    tokenValue += balance * price;
  }

  // Staking value (same as NEAR price)
  const stakingBalance = yoctoToNear(account.staking?.total_staked || '0');
  const stakingValue = stakingBalance * nearPrice;

  return {
    near: { 
      balance: nearBalance, 
      locked: lockedBalance,
      value: nearValue + lockedValue 
    },
    tokens: { 
      count: account.tokens?.length || 0, 
      value: tokenValue 
    },
    staking: { 
      balance: stakingBalance, 
      pools: account.staking?.pools?.length || 0,
      value: stakingValue 
    },
    nfts: { 
      count: account.nfts?.length || 0 
    },
    transactions: account.transaction_count || 0,
    totalValue: nearValue + lockedValue + tokenValue + stakingValue
  };
}

// Usage with example
const portfolio = await calculatePortfolioValue('therealmagyar.near', priceOracle);
console.log(`Total Portfolio Value: $${portfolio.totalValue.toFixed(2)}`);
console.log(`NEAR Balance: ${portfolio.near.balance.toFixed(6)} NEAR`);
console.log(`Staked: ${portfolio.staking.balance.toFixed(6)} NEAR across ${portfolio.staking.pools} pools`);
console.log(`Transactions: ${portfolio.transactions}`);
```

## Error Responses

### 400 Bad Request

```json
{
  "error": "Invalid account ID format",
  "code": 400
}
```

<Warning>
  Ensure the account ID follows NEAR naming conventions or is a valid 64-character implicit account hash.
</Warning>

### 401 Unauthorized

```json
{
  "error": "Missing or invalid API key",
  "code": 401
}
```

### 404 Not Found

```json
{
  "error": "Account not found",
  "code": 404,
  "account_id": "nonexistent.near"
}
```

<Note>
  A 404 error means the account does not exist on the blockchain.
</Note>

### 500 Internal Server Error

```json
{
  "error": "Failed to fetch account data",
  "code": 500
}
```

## Related Endpoints

<CardGroup cols={2}>
  <Card 
    title="Balance Only" 
    icon="wallet" 
    href="/shadow-api/endpoints/account-balance"
  >
    Get just the native NEAR balance
  </Card>
  
  <Card 
    title="Staking Positions" 
    icon="chart-pie" 
    href="/shadow-api/endpoints/account-stakings"
  >
    Query specific validator pool stakes
  </Card>
  
  <Card 
    title="Burrow Positions" 
    icon="building-columns" 
    href="/shadow-api/endpoints/burrow-DeFi-positions"
  >
    Get Burrow DeFi lending/borrowing data
  </Card>
  
  <Card 
    title="Account Transactions" 
    icon="receipt" 
    href="/shadow-api/endpoints/transactions"
  >
    View transaction history for account
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Caching Strategy" icon="database">
    Account data can change frequently. Implement smart caching:
    
    ```javascript
    const CACHE_DURATION = {
      balance: 30 * 1000,      // 30 seconds
      tokens: 60 * 1000,       // 1 minute
      nfts: 5 * 60 * 1000,     // 5 minutes
      labels: 60 * 60 * 1000   // 1 hour
    };
    
    class SmartCache {
      constructor() {
        this.cache = new Map();
      }
      
      async get(accountId, fetcher, type = 'balance') {
        const cached = this.cache.get(accountId);
        const maxAge = CACHE_DURATION[type];
        
        if (cached && Date.now() - cached.timestamp < maxAge) {
          return cached.data;
        }
        
        const data = await fetcher(accountId);
        this.cache.set(accountId, {
          data,
          timestamp: Date.now()
        });
        
        return data;
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Error Handling" icon="triangle-exclamation">
    Always handle potential errors gracefully:
    
    ```javascript
    async function safeGetAccountData(accountId) {
      try {
        const response = await fetch(
          `https://api.shadowcorp.dev/v1/accounts/${accountId}`,
          { headers: { 'X-API-Key': 'YOUR_KEY' } }
        );
        
        if (!response.ok) {
          if (response.status === 404) {
            return { 
              error: 'Account not found',
              account_id: accountId 
            };
          }
          throw new Error(`HTTP ${response.status}`);
        }
        
        return await response.json();
      } catch (error) {
        console.error(`Failed to fetch ${accountId}:`, error);
        return { error: error.message };
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Batch Processing" icon="layer-group">
    When fetching multiple accounts, use rate limiting:
    
    ```javascript
    async function batchGetAccounts(accountIds, batchSize = 5) {
      const results = [];
      
      for (let i = 0; i < accountIds.length; i += batchSize) {
        const batch = accountIds.slice(i, i + batchSize);
        const batchResults = await Promise.all(
          batch.map(id => getAccountData(id))
        );
        results.push(...batchResults);
        
        // Small delay between batches
        if (i + batchSize < accountIds.length) {
          await new Promise(resolve => setTimeout(resolve, 200));
        }
      }
      
      return results;
    }
    ```
  </Accordion>
  
  <Accordion title="Risk Score Interpretation" icon="shield">
    Use risk scores appropriately in your application:
    
    ```javascript
    function shouldAllowTransaction(account, transactionValue) {
      // Get risk score
      const riskScore = account.risk_score ?? 0;
      
      // Define thresholds based on transaction value
      if (transactionValue < 100) {
        // Low-value: allow up to moderate risk
        return riskScore <= 50;
      } else if (transactionValue < 1000) {
        // Medium-value: only low risk
        return riskScore <= 25;
      } else {
        // High-value: require very low risk
        return riskScore <= 10;
      }
    }
    
    // Usage
    const account = await getAccountData('user.near');
    if (!shouldAllowTransaction(account, 500)) {
      console.log('‚ö†Ô∏è  Transaction blocked due to risk score');
    }
    ```
  </Accordion>
</AccordionGroup>

## Performance Tips

<Tip>
  **Optimize API Usage:**
  - Use this endpoint when you need comprehensive account data
  - Use specific endpoints (`/balance`, `/staking`) when you only need one data type
  - Implement caching to reduce redundant requests
  - Batch account lookups when possible
</Tip>

<Note>
  The full account data endpoint aggregates data from multiple sources. For real-time applications requiring only balance updates, consider using the `/v1/accounts/:id/balance` endpoint instead.
</Note>
