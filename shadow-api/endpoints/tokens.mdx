---
title: Tokens
description: Access fungible token metadata and holder information on the NEAR blockchain. Get token details, top holders, and distribution metrics for any NEP-141 token.
icon: coin
---

import { Endpoint, Request } from '@mintlify/components';

## Get Token Metadata

<Endpoint method="GET" path="/v1/tokens/:id/metadata" />

Retrieve comprehensive metadata for any fungible token (FT) on NEAR, including name, symbol, decimals, and icon.

<Info>
  This endpoint supports all NEP-141 compliant fungible tokens on NEAR, including wrapped tokens, stablecoins, and DeFi tokens.
</Info>

### Path Parameters

<ParamField path="id" type="string" required>
  The token contract ID. This is the NEAR account that deployed the fungible token contract.
  
  **Examples:**
  - `wrap.near` - Wrapped NEAR
  - `usdt.tether-token.near` - Tether USD
  - `token.v2.ref-finance.near` - Ref Finance token
  - `aurora` - Aurora token
</ParamField>

### Making Requests

<Tabs>
  <Tab title="cURL">
    **Popular tokens:**
    ```bash
    # Wrapped NEAR
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/tokens/wrap.near/metadata"

    # USDT
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/tokens/usdt.tether-token.near/metadata"

    # Ref Finance
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/tokens/token.v2.ref-finance.near/metadata"

    # Aurora
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/tokens/aurora/metadata"
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    // Get token metadata
    const getTokenMetadata = async (contractId) => {
      const response = await fetch(
        `https://api.shadowcorp.dev/v1/tokens/${contractId}/metadata`,
        {
          headers: {
            'X-API-Key': 'YOUR_KEY'
          }
        }
      );
      return await response.json();
    };

    // Get multiple tokens
    const getMultipleTokens = async (contractIds) => {
      const promises = contractIds.map(id => 
        getTokenMetadata(id)
      );
      return await Promise.all(promises);
    };

    // Format token amount based on decimals
    const formatTokenAmount = (amount, decimals) => {
      return (parseInt(amount) / Math.pow(10, decimals)).toLocaleString();
    };

    // Usage
    const usdt = await getTokenMetadata('usdt.tether-token.near');
    console.log(`Token: ${usdt.name} (${usdt.symbol})`);
    console.log(`Decimals: ${usdt.decimals}`);

    // Format a balance
    const balance = "1000000"; // Raw balance from contract
    const formatted = formatTokenAmount(balance, usdt.decimals);
    console.log(`Balance: ${formatted} ${usdt.symbol}`);
    ```
  </Tab>
  
  <Tab title="Python">
    ```python
    import requests

    class TokenAPI:
        def __init__(self, api_key):
            self.base_url = 'https://api.shadowcorp.dev'
            self.headers = {'X-API-Key': api_key}
        
        def get_token_metadata(self, contract_id):
            """Get metadata for fungible token"""
            response = requests.get(
                f'{self.base_url}/v1/tokens/{contract_id}/metadata',
                headers=self.headers
            )
            return response.json()
        
        def get_multiple_tokens(self, contract_ids):
            """Get metadata for multiple tokens"""
            return [
                self.get_token_metadata(contract_id)
                for contract_id in contract_ids
            ]
        
        def format_token_amount(self, amount, decimals):
            """Format raw token amount with decimals"""
            return int(amount) / (10 ** decimals)
        
        def get_token_summary(self, contract_id):
            """Get formatted summary of token"""
            data = self.get_token_metadata(contract_id)
            return {
                'contract_id': data.get('contract_id'),
                'name': data.get('name'),
                'symbol': data.get('symbol'),
                'decimals': data.get('decimals'),
                'icon': data.get('icon')
            }

    # Usage
    api = TokenAPI('YOUR_KEY')
    
    # Single token
    usdt = api.get_token_metadata('usdt.tether-token.near')
    print(f"Token: {usdt['name']} ({usdt['symbol']})")
    print(f"Decimals: {usdt['decimals']}")
    
    # Multiple tokens
    tokens = api.get_multiple_tokens([
        'wrap.near',
        'usdt.tether-token.near',
        'aurora'
    ])
    
    for token in tokens:
        print(f"{token['symbol']}: {token['name']}")
    
    # Format balance
    raw_balance = "1000000"
    formatted = api.format_token_amount(raw_balance, usdt['decimals'])
    print(f"Balance: {formatted} {usdt['symbol']}")
    ```
  </Tab>
  
  <Tab title="Go">
    ```go
    package main

    import (
        "encoding/json"
        "fmt"
        "math"
        "net/http"
    )

    type TokenAPI struct {
        BaseURL string
        APIKey  string
        Client  *http.Client
    }

    type TokenMetadata struct {
        ContractID string  `json:"contract_id"`
        Name       string  `json:"name"`
        Symbol     string  `json:"symbol"`
        Decimals   int     `json:"decimals"`
        Icon       *string `json:"icon"`
    }

    func NewTokenAPI(apiKey string) *TokenAPI {
        return &TokenAPI{
            BaseURL: "https://api.shadowcorp.dev",
            APIKey:  apiKey,
            Client:  &http.Client{},
        }
    }

    func (t *TokenAPI) GetTokenMetadata(contractID string) (*TokenMetadata, error) {
        reqURL := fmt.Sprintf("%s/v1/tokens/%s/metadata", t.BaseURL, contractID)
        
        req, err := http.NewRequest("GET", reqURL, nil)
        if err != nil {
            return nil, err
        }
        
        req.Header.Add("X-API-Key", t.APIKey)
        
        resp, err := t.Client.Do(req)
        if err != nil {
            return nil, err
        }
        defer resp.Body.Close()

        var metadata TokenMetadata
        if err := json.NewDecoder(resp.Body).Decode(&metadata); err != nil {
            return nil, err
        }
        
        return &metadata, nil
    }

    func (t *TokenAPI) FormatTokenAmount(amount string, decimals int) float64 {
        var rawAmount float64
        fmt.Sscanf(amount, "%f", &rawAmount)
        return rawAmount / math.Pow(10, float64(decimals))
    }

    func main() {
        api := NewTokenAPI("YOUR_KEY")
        
        // Get token metadata
        usdt, err := api.GetTokenMetadata("usdt.tether-token.near")
        if err != nil {
            panic(err)
        }
        
        fmt.Printf("Token: %s (%s)\n", usdt.Name, usdt.Symbol)
        fmt.Printf("Decimals: %d\n", usdt.Decimals)
        
        // Format balance
        rawBalance := "1000000"
        formatted := api.FormatTokenAmount(rawBalance, usdt.Decimals)
        fmt.Printf("Balance: %.2f %s\n", formatted, usdt.Symbol)
    }
    ```
  </Tab>
</Tabs>

### Response Format

<ResponseField name="contract_id" type="string" required>
  The token contract address.
</ResponseField>

<ResponseField name="name" type="string" required>
  Full name of the token (e.g., "Wrapped NEAR", "Tether USD").
</ResponseField>

<ResponseField name="symbol" type="string" required>
  Trading symbol or ticker (e.g., "wNEAR", "USDT").
</ResponseField>

<ResponseField name="decimals" type="integer" required>
  Number of decimal places for the token. Used to convert raw amounts to human-readable values.
</ResponseField>

<ResponseField name="icon" type="string">
  URL or data URI of the token's icon image. Returns `null` if not set.
</ResponseField>

### Success Response (200 OK)

```json
{
  "contract_id": "usdt.tether-token.near",
  "name": "Tether USD",
  "symbol": "USDT",
  "decimals": 6,
  "icon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAASbSURBVHgB7Z0NUhNBEIZ7EhEUUEGUS..."
}
```

<Check>
  A `200 OK` status code indicates the token metadata was retrieved successfully.
</Check>

---

## Get Top Token Holders

<Endpoint method="GET" path="/v1/tokens/:id/holders" />

Retrieve the top holders of any fungible token, sorted by balance. Useful for analyzing token distribution and whale tracking.

### Path Parameters

<ParamField path="id" type="string" required>
  The token contract ID (same as metadata endpoint).
</ParamField>

### Query Parameters

<ParamField query="limit" type="integer" default="50">
  Number of holders to return. Maximum: 100.
</ParamField>

<ParamField query="offset" type="integer" default="0">
  Number of holders to skip for pagination.
</ParamField>

### Making Requests

<Tabs>
  <Tab title="cURL">
    ```bash
    # Top 10 USDT holders
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/tokens/usdt.tether-token.near/holders?limit=10"

    # Top 50 wNEAR holders
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/tokens/wrap.near/holders?limit=50"

    # Pagination example
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/tokens/usdt.tether-token.near/holders?limit=100&offset=100"
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    // Get top holders
    const getTopHolders = async (contractId, limit = 50) => {
      const response = await fetch(
        `https://api.shadowcorp.dev/v1/tokens/${contractId}/holders?limit=${limit}`,
        {
          headers: {
            'X-API-Key': 'YOUR_KEY'
          }
        }
      );
      return await response.json();
    };

    // Calculate holder concentration
    const analyzeDistribution = async (contractId) => {
      const holders = await getTopHolders(contractId, 100);
      const metadata = await getTokenMetadata(contractId);
      
      const totalTop10 = holders.data
        .slice(0, 10)
        .reduce((sum, h) => sum + parseFloat(h.balance), 0);
      
      const totalTop50 = holders.data
        .slice(0, 50)
        .reduce((sum, h) => sum + parseFloat(h.balance), 0);
      
      return {
        token: metadata.symbol,
        top10Balance: totalTop10,
        top50Balance: totalTop50,
        holders: holders.total
      };
    };

    // Usage
    const holders = await getTopHolders('usdt.tether-token.near', 10);
    console.log(`Top 10 USDT Holders:`);
    holders.data.forEach((holder, i) => {
      console.log(`${i + 1}. ${holder.account_id}: ${holder.balance}`);
    });

    // Analyze distribution
    const stats = await analyzeDistribution('usdt.tether-token.near');
    console.log(`Top 10 holders control: ${stats.top10Balance.toFixed(2)} USDT`);
    ```
  </Tab>
  
  <Tab title="Python">
    ```python
    class TokenAPI:
        # ... (previous methods)
        
        def get_top_holders(self, contract_id, limit=50, offset=0):
            """Get top token holders"""
            params = {'limit': limit, 'offset': offset}
            response = requests.get(
                f'{self.base_url}/v1/tokens/{contract_id}/holders',
                headers=self.headers,
                params=params
            )
            return response.json()
        
        def analyze_distribution(self, contract_id, top_n=10):
            """Analyze token distribution concentration"""
            holders = self.get_top_holders(contract_id, limit=100)
            metadata = self.get_token_metadata(contract_id)
            
            top_holders = holders['data'][:top_n]
            total_top = sum(float(h['balance']) for h in top_holders)
            
            return {
                'token': metadata['symbol'],
                f'top_{top_n}_balance': total_top,
                'total_holders': holders['total'],
                'concentration': (total_top / sum(float(h['balance']) 
                    for h in holders['data'])) * 100
            }

    # Usage
    api = TokenAPI('YOUR_KEY')
    
    # Get top holders
    holders = api.get_top_holders('usdt.tether-token.near', limit=10)
    print(f"Top 10 USDT Holders:")
    for i, holder in enumerate(holders['data'], 1):
        print(f"{i}. {holder['account_id']}: {holder['balance']}")
    
    # Analyze distribution
    stats = api.analyze_distribution('usdt.tether-token.near')
    print(f"\nTop 10 holders control: {stats['top_10_balance']:.2f} USDT")
    print(f"Concentration: {stats['concentration']:.2f}%")
    ```
  </Tab>
  
  <Tab title="Go">
    ```go
    type Holder struct {
        AccountID string `json:"account_id"`
        Balance   string `json:"balance"`
    }

    type HoldersResponse struct {
        Data   []Holder `json:"data"`
        Total  int      `json:"total"`
        Limit  int      `json:"limit"`
        Offset int      `json:"offset"`
    }

    func (t *TokenAPI) GetTopHolders(contractID string, limit, offset int) (*HoldersResponse, error) {
        reqURL := fmt.Sprintf(
            "%s/v1/tokens/%s/holders?limit=%d&offset=%d",
            t.BaseURL, contractID, limit, offset,
        )
        
        req, err := http.NewRequest("GET", reqURL, nil)
        if err != nil {
            return nil, err
        }
        
        req.Header.Add("X-API-Key", t.APIKey)
        
        resp, err := t.Client.Do(req)
        if err != nil {
            return nil, err
        }
        defer resp.Body.Close()

        var holders HoldersResponse
        if err := json.NewDecoder(resp.Body).Decode(&holders); err != nil {
            return nil, err
        }
        
        return &holders, nil
    }

    func main() {
        api := NewTokenAPI("YOUR_KEY")
        
        // Get top 10 holders
        holders, err := api.GetTopHolders("usdt.tether-token.near", 10, 0)
        if err != nil {
            panic(err)
        }
        
        fmt.Println("Top 10 USDT Holders:")
        for i, holder := range holders.Data {
            fmt.Printf("%d. %s: %s\n", i+1, holder.AccountID, holder.Balance)
        }
    }
    ```
  </Tab>
</Tabs>

### Response Format

<ResponseField name="data" type="array" required>
  Array of holder objects, sorted by balance (descending).
  
  <Expandable title="Holder Object">
    <ResponseField name="account_id" type="string">
      NEAR account ID of the token holder.
    </ResponseField>
    
    <ResponseField name="balance" type="string">
      Raw token balance (needs to be divided by 10^decimals for human-readable value).
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="total" type="integer" required>
  Total number of holders for this token.
</ResponseField>

<ResponseField name="limit" type="integer" required>
  Number of holders returned in this response.
</ResponseField>

<ResponseField name="offset" type="integer" required>
  Current pagination offset.
</ResponseField>

### Success Response (200 OK)

```json
{
  "data": [
    {
      "account_id": "binance.near",
      "balance": "123456789000"
    },
    {
      "account_id": "ref-finance.near",
      "balance": "98765432100"
    },
    {
      "account_id": "whale.near",
      "balance": "45678901230"
    }
  ],
  "total": 15847,
  "limit": 3,
  "offset": 0
}
```

<Check>
  Balances are returned as raw strings. Divide by 10^decimals to get the human-readable value.
</Check>

## Understanding Token Decimals

<AccordionGroup>
  <Accordion title="Why Decimals Matter" icon="calculator">
    Tokens store balances as integers to avoid floating-point precision issues. The `decimals` field tells you how to convert these raw values to human-readable amounts.
    
    **Example:**
    - Raw balance: `"1000000"`
    - Decimals: `6` (USDT)
    - Human-readable: `1000000 / 10^6 = 1.0 USDT`
    
    ```javascript
    function formatBalance(rawBalance, decimals) {
      return (parseInt(rawBalance) / Math.pow(10, decimals)).toFixed(decimals);
    }
    
    formatBalance("1000000", 6);  // "1.000000"
    formatBalance("123456789", 6); // "123.456789"
    ```
  </Accordion>
  
  <Accordion title="Common Token Decimals" icon="list">
    Different tokens use different decimal precisions:
    
    | Token | Decimals | Example |
    |-------|----------|---------|
    | USDT | 6 | `1000000` = 1 USDT |
    | wNEAR | 24 | `1000000000000000000000000` = 1 wNEAR |
    | REF | 18 | `1000000000000000000` = 1 REF |
    | AURORA | 18 | `1000000000000000000` = 1 AURORA |
    
    <Tip>
      Always fetch metadata first to get the correct decimals before displaying balances.
    </Tip>
  </Accordion>
  
  <Accordion title="Handling Large Numbers" icon="hashtag">
    Token balances can exceed JavaScript's safe integer limit. Use BigInt or string arithmetic:
    
    ```javascript
    // ‚ùå Wrong - loses precision
    const balance = 1234567890123456789012345;
    const formatted = balance / 1e24;
    
    // ‚úÖ Correct - using BigInt
    const balance = BigInt("1234567890123456789012345");
    const decimals = 24;
    const divisor = BigInt(10) ** BigInt(decimals);
    const formatted = Number(balance) / Number(divisor);
    
    // ‚úÖ Correct - using library
    import { formatUnits } from 'ethers'; // or similar
    const formatted = formatUnits("1234567890123456789012345", 24);
    ```
  </Accordion>
</AccordionGroup>

## Use Cases

<CardGroup cols={2}>
  <Card title="Token Portfolio Tracker" icon="wallet" color="#3b82f6">
    Build wallet dashboards showing all token balances with accurate formatting.
  </Card>
  
  <Card title="Whale Alert Systems" icon="fish" color="#8b5cf6">
    Monitor large holders and track significant balance changes.
  </Card>
  
  <Card title="DEX Integrations" icon="arrow-right-arrow-left" color="#10b981">
    Display token information and validate contracts in trading interfaces.
  </Card>
  
  <Card title="Distribution Analysis" icon="chart-pie" color="#f59e0b">
    Analyze token concentration and decentralization metrics.
  </Card>
</CardGroup>

## Advanced Example: Token Analytics Dashboard

Here's a complete token analysis tool:

```javascript
class TokenAnalyzer {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.shadowcorp.dev';
  }

  async getTokenMetadata(contractId) {
    const response = await fetch(
      `${this.baseUrl}/v1/tokens/${contractId}/metadata`,
      { headers: { 'X-API-Key': this.apiKey } }
    );
    return await response.json();
  }

  async getTopHolders(contractId, limit = 100) {
    const response = await fetch(
      `${this.baseUrl}/v1/tokens/${contractId}/holders?limit=${limit}`,
      { headers: { 'X-API-Key': this.apiKey } }
    );
    return await response.json();
  }

  formatBalance(rawBalance, decimals) {
    const balance = BigInt(rawBalance);
    const divisor = BigInt(10) ** BigInt(decimals);
    const whole = balance / divisor;
    const fraction = balance % divisor;
    
    const fractionStr = fraction.toString().padStart(decimals, '0');
    return `${whole}.${fractionStr}`;
  }

  async analyzeToken(contractId) {
    console.log(`üîç Analyzing ${contractId}...\n`);
    
    // Get metadata
    const metadata = await this.getTokenMetadata(contractId);
    console.log(`Token: ${metadata.name} (${metadata.symbol})`);
    console.log(`Decimals: ${metadata.decimals}`);
    console.log(`Contract: ${metadata.contract_id}\n`);
    
    // Get holders
    const holders = await this.getTopHolders(contractId, 100);
    console.log(`Total Holders: ${holders.total.toLocaleString()}\n`);
    
    // Calculate distribution
    const balances = holders.data.map(h => 
      parseFloat(this.formatBalance(h.balance, metadata.decimals))
    );
    
    const total = balances.reduce((sum, bal) => sum + bal, 0);
    const top10 = balances.slice(0, 10).reduce((sum, bal) => sum + bal, 0);
    const top50 = balances.slice(0, 50).reduce((sum, bal) => sum + bal, 0);
    
    console.log(`üìä Distribution Analysis:`);
    console.log(`  Top 10 holders: ${top10.toLocaleString()} ${metadata.symbol} (${((top10/total)*100).toFixed(2)}%)`);
    console.log(`  Top 50 holders: ${top50.toLocaleString()} ${metadata.symbol} (${((top50/total)*100).toFixed(2)}%)`);
    console.log(`  Top 100 total: ${total.toLocaleString()} ${metadata.symbol}\n`);
    
    // Display top holders
    console.log(`üêã Top 10 Holders:`);
    holders.data.slice(0, 10).forEach((holder, i) => {
      const balance = this.formatBalance(holder.balance, metadata.decimals);
      const percentage = ((parseFloat(balance) / total) * 100).toFixed(2);
      console.log(`  ${i + 1}. ${holder.account_id}`);
      console.log(`     Balance: ${parseFloat(balance).toLocaleString()} ${metadata.symbol} (${percentage}%)`);
    });
    
    return {
      metadata,
      holders: holders.total,
      distribution: {
        top10Percentage: (top10/total) * 100,
        top50Percentage: (top50/total) * 100,
        top10Balance: top10,
        top50Balance: top50
      }
    };
  }

  async compareTokens(contractIds) {
    console.log(`üìä Comparing ${contractIds.length} tokens...\n`);
    
    const results = [];
    for (const contractId of contractIds) {
      const metadata = await this.getTokenMetadata(contractId);
      const holders = await this.getTopHolders(contractId, 100);
      
      const balances = holders.data.map(h => 
        parseFloat(this.formatBalance(h.balance, metadata.decimals))
      );
      const total = balances.reduce((sum, bal) => sum + bal, 0);
      const top10 = balances.slice(0, 10).reduce((sum, bal) => sum + bal, 0);
      
      results.push({
        symbol: metadata.symbol,
        name: metadata.name,
        holders: holders.total,
        top10Concentration: (top10 / total) * 100
      });
    }
    
    // Display comparison table
    console.log('Token Comparison:');
    console.log('‚îÄ'.repeat(80));
    console.log(
      'Symbol'.padEnd(12) + 
      'Name'.padEnd(30) + 
      'Holders'.padEnd(15) + 
      'Top 10%'
    );
    console.log('‚îÄ'.repeat(80));
    
    results.forEach(r => {
      console.log(
        r.symbol.padEnd(12) +
        r.name.substring(0, 28).padEnd(30) +
        r.holders.toLocaleString().padEnd(15) +
        r.top10Concentration.toFixed(2) + '%'
      );
    });
    
    console.log('‚îÄ'.repeat(80));
    
    return results;
  }
}

// Usage
const analyzer = new TokenAnalyzer('YOUR_KEY');

// Analyze single token
await analyzer.analyzeToken('usdt.tether-token.near');

// Compare multiple tokens
await analyzer.compareTokens([
  'usdt.tether-token.near',
  'wrap.near',
  'token.v2.ref-finance.near',
  'aurora'
]);
```

## Whale Tracking Example

Monitor large token holders and detect significant changes:

```javascript
class WhaleTracker {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.shadowcorp.dev';
    this.snapshots = new Map();
  }

  async trackToken(contractId, threshold = 1000000) {
    const metadata = await this.getTokenMetadata(contractId);
    const holders = await this.getTopHolders(contractId, 50);
    
    const whales = holders.data.filter(h => {
      const balance = parseFloat(h.balance) / Math.pow(10, metadata.decimals);
      return balance >= threshold;
    });
    
    console.log(`üêã Found ${whales.length} whales holding ${threshold}+ ${metadata.symbol}\n`);
    
    whales.forEach((whale, i) => {
      const balance = parseFloat(whale.balance) / Math.pow(10, metadata.decimals);
      console.log(`${i + 1}. ${whale.account_id}: ${balance.toLocaleString()} ${metadata.symbol}`);
    });
    
    // Store snapshot
    this.snapshots.set(contractId, {
      timestamp: Date.now(),
      whales: whales.map(w => ({
        account: w.account_id,
        balance: w.balance
      }))
    });
    
    return whales;
  }

  async detectChanges(contractId) {
    const previous = this.snapshots.get(contractId);
    if (!previous) {
      console.log('No previous snapshot found. Run trackToken first.');
      return;
    }
    
    const metadata = await this.getTokenMetadata(contractId);
    const current = await this.getTopHolders(contractId, 50);
    
    console.log(`üîç Detecting changes since ${new Date(previous.timestamp).toLocaleString()}\n`);
    
    // Compare balances
    const changes = [];
    current.data.forEach(holder => {
      const prev = previous.whales.find(w => w.account === holder.account_id);
      if (prev) {
        const oldBalance = parseFloat(prev.balance) / Math.pow(10, metadata.decimals);
        const newBalance = parseFloat(holder.balance) / Math.pow(10, metadata.decimals);
        const diff = newBalance - oldBalance;
        const percentChange = (diff / oldBalance) * 100;
        
        if (Math.abs(percentChange) > 5) { // 5% change threshold
          changes.push({
            account: holder.account_id,
            oldBalance,
            newBalance,
            diff,
            percentChange
          });
        }
      }
    });
    
    if (changes.length === 0) {
      console.log('No significant changes detected.');
      return;
    }
    
    console.log(`‚ö†Ô∏è  Detected ${changes.length} significant balance changes:\n`);
    changes.forEach(change => {
      const emoji = change.diff > 0 ? 'üìà' : 'üìâ';
      console.log(`${emoji} ${change.account}`);
      console.log(`   Old: ${change.oldBalance.toLocaleString()} ${metadata.symbol}`);
      console.log(`   New: ${change.newBalance.toLocaleString()} ${metadata.symbol}`);
      console.log(`   Change: ${change.diff > 0 ? '+' : ''}${change.diff.toLocaleString()} (${change.percentChange.toFixed(2)}%)\n`);
    });
    
    return changes;
  }

  async getTokenMetadata(contractId) {
    const response = await fetch(
      `${this.baseUrl}/v1/tokens/${contractId}/metadata`,
      { headers: { 'X-API-Key': this.apiKey } }
    );
    return await response.json();
  }

  async getTopHolders(contractId, limit) {
    const response = await fetch(
      `${this.baseUrl}/v1/tokens/${contractId}/holders?limit=${limit}`,
      { headers: { 'X-API-Key': this.apiKey } }
    );
    return await response.json();
  }
}

// Usage
const tracker = new WhaleTracker('YOUR_KEY');

// Initial snapshot
await tracker.trackToken('usdt.tether-token.near', 1000000);

// Check for changes later
setTimeout(async () => {
  await tracker.detectChanges('usdt.tether-token.near');
}, 60000); // Check after 1 minute
```

## Error Responses

### 400 Bad Request

```json
{
  "error": "Invalid contract ID format",
  "code": 400
}
```

<Warning>
  Ensure the contract ID follows NEAR naming conventions.
</Warning>

### 401 Unauthorized

```json
{
  "error": "Missing or invalid API key",
  "code": 401
}
```

### 404 Not Found

```json
{
  "error": "Token not found",
  "code": 404,
  "contract_id": "invalid.near"
}
```

<Note>
  A 404 error means the contract either does not exist or is not a fungible token contract (NEP-141).
</Note>

### 500 Internal Server Error

```json
{
  "error": "Failed to fetch token data",
  "code": 500
}
```

## Related Endpoints

<CardGroup cols={2}>
  <Card 
    title="FT Transfers" 
    icon="right-left" 
    href="/shadow-api/endpoints/ft-transfers"
  >
    Track all fungible token transfers
  </Card>
  
  <Card 
    title="Account Tokens" 
    icon="wallet" 
    href="/shadow-api/endpoints/full-account-data"
  >
    View all tokens owned by an account
  </Card>
  
  <Card 
    title="Token Activity" 
    icon="chart-line" 
    href="/shadow-api/endpoints/ft-transfers"
  >
    Monitor real-time token trading activity
  </Card>
  
  <Card 
    title="Validator Analytics" 
    icon="server" 
    href="/shadow-api/endpoints/all-current-validators"
  >
    Analyze Validators
  </Card>
</CardGroup>

## Best Practices

<AccordionGroup>
  <Accordion title="Caching Token Metadata" icon="database">
    Token metadata rarely changes. Cache it aggressively:
    
    ```javascript
    class TokenCache {
      constructor(apiKey) {
        this.apiKey = apiKey;
        this.cache = new Map();
        this.ttl = 24 * 60 * 60 * 1000; // 24 hours
      }
      
      async getMetadata(contractId) {
        const cached = this.cache.get(contractId);
        
        if (cached && Date.now() - cached.timestamp < this.ttl) {
          return cached.data;
        }
        
        const response = await fetch(
          `https://api.shadowcorp.dev/v1/tokens/${contractId}/metadata`,
          { headers: { 'X-API-Key': this.apiKey } }
        );
        const data = await response.json();
        
        this.cache.set(contractId, {
          data,
          timestamp: Date.now()
        });
        
        return data;
      }
    }
    ```
  </Accordion>
  
  <Accordion title="Handling Balance Precision" icon="calculator">
    Always use proper decimal handling for token balances:
    
    ```javascript
    // ‚ùå Wrong - loses precision
    const balance = parseInt("1234567890123456789012345");
    
    // ‚úÖ Correct - use BigInt
    const balance = BigInt("1234567890123456789012345");
    const decimals = 24;
    const divisor = BigInt(10) ** BigInt(decimals);
    
    // For display
    const displayBalance = (
      Number(balance) / Number(divisor)
    ).toFixed(4);
    
    // For calculations, keep as BigInt
    const fee = balance * BigInt(5) / BigInt(10000); // 0.05% fee
    ```
  </Accordion>
  
  <Accordion title="Rate Limiting & Batch Requests" icon="gauge">
    When fetching multiple tokens, add delays to respect rate limits:
    
    ```javascript
    async function fetchMultipleTokens(contractIds) {
      const results = [];
      
      for (const id of contractIds) {
        try {
          const metadata = await getTokenMetadata(id);
          results.push(metadata);
          
          // Small delay between requests
          await new Promise(resolve => setTimeout(resolve, 100));
        } catch (error) {
          console.error(`Failed to fetch ${id}:`, error);
          results.push({ error: error.message, contract_id: id });
        }
      }
      
      return results;
    }
    ```
  </Accordion>
  
  <Accordion title="Holder Data Refresh" icon="arrows-rotate">
    Holder data changes frequently. Refresh it based on your use case:
    
    ```javascript
    class HolderMonitor {
      constructor(apiKey, refreshInterval = 60000) {
        this.apiKey = apiKey;
        this.refreshInterval = refreshInterval; // 1 minute default
        this.data = new Map();
      }
      
      async startMonitoring(contractId) {
        // Initial fetch
        await this.updateHolders(contractId);
        
        // Set up periodic refresh
        setInterval(async () => {
          await this.updateHolders(contractId);
        }, this.refreshInterval);
      }
      
      async updateHolders(contractId) {
        try {
          const response = await fetch(
            `https://api.shadowcorp.dev/v1/tokens/${contractId}/holders?limit=100`,
            { headers: { 'X-API-Key': this.apiKey } }
          );
          const holders = await response.json();
          
          this.data.set(contractId, {
            holders: holders.data,
            total: holders.total,
            timestamp: Date.now()
          });
          
          console.log(`‚úÖ Updated ${contractId} holders (${holders.total} total)`);
        } catch (error) {
          console.error(`‚ùå Failed to update ${contractId}:`, error);
        }
      }
      
      getHolders(contractId) {
        return this.data.get(contractId);
      }
    }
    ```
  </Accordion>
</AccordionGroup>