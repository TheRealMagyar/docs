---
title: FT Transfers
description: Access comprehensive fungible token (FT) transfer data from the NEAR blockchain. Track token movements, analyze flows, and monitor account activity for NEP-141 compliant tokens.
icon: coins
---

import { Endpoint } from '@mintlify/components';

<Endpoint method="GET" path="/v1/ft-transfers" />

Retrieve a paginated list of fungible token transfers with optional filtering by account.

<Info>
  This endpoint tracks all NEP-141 fungible token transfers, including USDT, wrapped NEAR, and other tokens.
</Info>

## Query Parameters

<ParamField query="limit" type="integer" default="50">
  Number of transfers to return per request. Maximum: 100.
</ParamField>

<ParamField query="offset" type="integer" default="0">
  Number of transfers to skip for pagination.
</ParamField>

<ParamField query="account" type="string">
  Filter transfers by account ID. Returns transfers where the account is either sender or receiver.
</ParamField>

## Making Requests

<Tabs>
  <Tab title="cURL">
    **All transfers:**
    ```bash
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/ft-transfers?limit=50"
    ```

    **Filter by account:**
    ```bash
    curl -H "X-API-Key: YOUR_KEY" \
      "https://api.shadowcorp.dev/v1/ft-transfers?account=example.near"
    ```
  </Tab>
  
  <Tab title="JavaScript">
    ```javascript
    const getFTTransfers = async (limit = 50, offset = 0) => {
      const response = await fetch(
        `https://api.shadowcorp.dev/v1/ft-transfers?limit=${limit}&offset=${offset}`,
        {
          headers: {
            'X-API-Key': 'YOUR_KEY'
          }
        }
      );
      return await response.json();
    };

    // Get transfers for specific account
    const getAccountFTTransfers = async (accountId) => {
      const response = await fetch(
        `https://api.shadowcorp.dev/v1/ft-transfers?account=${accountId}`,
        {
          headers: {
            'X-API-Key': 'YOUR_KEY'
          }
        }
      );
      return await response.json();
    };

    // Usage
    const allTransfers = await getFTTransfers(10);
    const userTransfers = await getAccountFTTransfers('example.near');
    console.log('User FT transfers:', userTransfers);
    ```
  </Tab>
  
  <Tab title="Python">
    ```python
    import requests

    class FTTransferAPI:
        def __init__(self, api_key):
            self.base_url = 'https://api.shadowcorp.dev'
            self.headers = {'X-API-Key': api_key}
        
        def get_ft_transfers(self, limit=50, offset=0):
            """Get all FT transfers with pagination"""
            params = {'limit': limit, 'offset': offset}
            response = requests.get(
                f'{self.base_url}/v1/ft-transfers',
                headers=self.headers,
                params=params
            )
            return response.json()
        
        def get_account_ft_transfers(self, account_id):
            """Get FT transfers for specific account"""
            params = {'account': account_id}
            response = requests.get(
                f'{self.base_url}/v1/ft-transfers',
                headers=self.headers,
                params=params
            )
            return response.json()
        
        def analyze_account_activity(self, account_id):
            """Analyze FT transfer activity for an account"""
            transfers = self.get_account_ft_transfers(account_id)
            
            sent = [t for t in transfers['data'] if t['from_account_id'] == account_id]
            received = [t for t in transfers['data'] if t['to_account_id'] == account_id]
            
            return {
                'total_transfers': len(transfers['data']),
                'sent': len(sent),
                'received': len(received),
                'unique_tokens': len(set(t['contract_id'] for t in transfers['data']))
            }

    # Usage
    api = FTTransferAPI('YOUR_KEY')
    transfers = api.get_account_ft_transfers('example.near')
    activity = api.analyze_account_activity('example.near')
    print(f"Total transfers: {activity['total_transfers']}")
    ```
  </Tab>
  
  <Tab title="Go">
    ```go
    package main

    import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
    )

    type FTTransferClient struct {
        BaseURL string
        APIKey  string
        Client  *http.Client
    }

    type FTTransferResponse struct {
        Data   []FTTransfer `json:"data"`
        Total  int          `json:"total"`
        Limit  int          `json:"limit"`
        Offset int          `json:"offset"`
    }

    type FTTransfer struct {
        ReceiptID      string   `json:"receipt_id"`
        BlockTimestamp string   `json:"block_timestamp"`
        BlockHeight    int64    `json:"block_height"`
        ContractID     string   `json:"contract_id"`
        FromAccountID  string   `json:"from_account_id"`
        ToAccountID    string   `json:"to_account_id"`
        Amount         string   `json:"amount"`
        TokenIDs       []string `json:"token_ids"`
        Memo           string   `json:"memo"`
    }

    func NewFTTransferClient(apiKey string) *FTTransferClient {
        return &FTTransferClient{
            BaseURL: "https://api.shadowcorp.dev",
            APIKey:  apiKey,
            Client:  &http.Client{},
        }
    }

    func (c *FTTransferClient) GetFTTransfers(limit, offset int) (*FTTransferResponse, error) {
        params := url.Values{}
        params.Add("limit", fmt.Sprintf("%d", limit))
        params.Add("offset", fmt.Sprintf("%d", offset))
        
        return c.makeRequest(params)
    }

    func (c *FTTransferClient) GetAccountFTTransfers(accountID string) (*FTTransferResponse, error) {
        params := url.Values{}
        params.Add("account", accountID)
        
        return c.makeRequest(params)
    }

    func (c *FTTransferClient) makeRequest(params url.Values) (*FTTransferResponse, error) {
        reqURL := fmt.Sprintf("%s/v1/ft-transfers?%s", c.BaseURL, params.Encode())
        
        req, err := http.NewRequest("GET", reqURL, nil)
        if err != nil {
            return nil, err
        }
        
        req.Header.Add("X-API-Key", c.APIKey)
        
        resp, err := c.Client.Do(req)
        if err != nil {
            return nil, err
        }
        defer resp.Body.Close()

        var result FTTransferResponse
        json.NewDecoder(resp.Body).Decode(&result)
        return &result, nil
    }

    func main() {
        client := NewFTTransferClient("YOUR_KEY")
        transfers, _ := client.GetAccountFTTransfers("example.near")
        fmt.Printf("Found %d FT transfers\n", len(transfers.Data))
    }
    ```
  </Tab>
</Tabs>

## Response Format

<ResponseField name="data" type="array" required>
  Array of FT transfer objects.
  
  <Expandable title="FT Transfer Object">
    <ResponseField name="receipt_id" type="string">
      Unique receipt identifier for this transfer operation.
    </ResponseField>
    
    <ResponseField name="block_timestamp" type="string">
      ISO 8601 timestamp when the transfer was executed.
    </ResponseField>
    
    <ResponseField name="block_height" type="integer">
      The block height where this transfer occurred.
    </ResponseField>
    
    <ResponseField name="contract_id" type="string">
      The fungible token contract address (e.g., `usdt.tether-token.near`).
    </ResponseField>
    
    <ResponseField name="from_account_id" type="string">
      Account ID that sent the tokens.
    </ResponseField>
    
    <ResponseField name="to_account_id" type="string">
      Account ID that received the tokens.
    </ResponseField>
    
    <ResponseField name="amount" type="string">
      Amount of tokens transferred (as string to preserve precision). The actual value depends on the token's decimals.
    </ResponseField>
    
    <ResponseField name="token_ids" type="array" nullable>
      Array of token IDs (usually `null` for fungible tokens, used in some multi-token standards).
    </ResponseField>
    
    <ResponseField name="memo" type="string">
      Optional memo/note attached to the transfer.
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="total" type="integer" required>
  Total number of FT transfers matching the query.
</ResponseField>

<ResponseField name="limit" type="integer" required>
  Number of transfers returned in this response.
</ResponseField>

<ResponseField name="offset" type="integer" required>
  Current pagination offset.
</ResponseField>

### Success Response (200 OK)

```json
{
  "data": [
    {
      "receipt_id": "3xECr8ziMCk1AcAVNxtPCn8CMZJuz3ZCxFc3rJnNivtS",
      "block_timestamp": "2026-01-01T20:57:29.641844Z",
      "block_height": 179321914,
      "contract_id": "wallet.kaiching",
      "from_account_id": "earn.kaiching",
      "to_account_id": "ffo8qmkqls33.users.kaiching",
      "amount": "350",
      "token_ids": null,
      "memo": "sws:04973f7a87f7e967449fb0d50346b028a7e3d6a9b1d9e1a21b21d4cbe3d2d541,T-e7ecd-oe006-2026-01-01"
    }
  ],
  "total": 1,
  "limit": 1,
  "offset": 0
}
```

<Check>
  A `200 OK` status code with the `data` array indicates success.
</Check>

## Understanding FT Transfer Fields

<AccordionGroup>
  <Accordion title="Receipt ID" icon="receipt">
    The `receipt_id` is a unique identifier for the receipt that executed this transfer. In NEAR, actions are executed through receipts, which are like internal transactions.
    
    **Use case:** Use receipt IDs to track and reference specific transfer operations or to investigate transaction flows.
  </Accordion>
  
  <Accordion title="Contract ID (Token Address)" icon="file-contract">
    The `contract_id` identifies the fungible token contract. This is the "address" of the token on NEAR.
    
    **Common examples:**
    - `usdt.tether-token.near` - USDT
    - `wrap.near` - Wrapped NEAR (wNEAR)
    - `token.sweat` - SWEAT token
    
    <Tip>
      Use the [Token Metadata endpoint](/shadow-api/endpoints/tokens) to get human-readable information about a token contract.
    </Tip>
  </Accordion>
  
  <Accordion title="Amount Field" icon="calculator">
    The `amount` is returned as a string to preserve precision for large numbers. The actual token value depends on the token's decimal places.
    
    **Example calculation:**
    ```javascript
    // If a token has 18 decimals (like wNEAR)
    const rawAmount = "1000000000000000000"; // from API
    const decimals = 18;
    const actualAmount = parseFloat(rawAmount) / Math.pow(10, decimals);
    console.log(actualAmount); // 1.0 token
    ```
    
    <Warning>
      Always check the token's decimal places before displaying amounts to users. Different tokens use different decimal configurations (commonly 6, 8, 18, or 24).
    </Warning>
  </Accordion>
  
  <Accordion title="Memo Field" icon="note-sticky">
    The `memo` field contains optional metadata about the transfer. Applications often use this to:
    - Add payment references
    - Include transaction descriptions
    - Store application-specific data
    - Link to external systems
    
    **Example from response:**
    ```
    "sws:04973f7a87f7e967449fb0d50346b028a7e3d6a9b1d9e1a21b21d4cbe3d2d541,T-e7ecd-oe006-2026-01-01"
    ```
    This appears to be an application-specific identifier with a reference code and date.
  </Accordion>
  
  <Accordion title="Filtering by Account" icon="filter">
    When you filter by account, you get transfers where the account is **either** sender **or** receiver.
    
    ```javascript
    // To separate sent vs received transfers:
    const transfers = await getAccountFTTransfers('example.near');
    
    const sent = transfers.data.filter(
      t => t.from_account_id === 'example.near'
    );
    const received = transfers.data.filter(
      t => t.to_account_id === 'example.near'
    );
    
    console.log(`Sent: ${sent.length}, Received: ${received.length}`);
    ```
  </Accordion>
</AccordionGroup>

## Use Cases

<CardGroup cols={2}>
  <Card title="Wallet Transaction History" icon="wallet" color="#3b82f6">
    Display token transfer history in wallet applications with proper token amounts and metadata.
  </Card>
  
  <Card title="Token Flow Analysis" icon="diagram-sankey" color="#8b5cf6">
    Analyze token flows between accounts for compliance, forensics, or analytics.
  </Card>
  
  <Card title="Trading Bot Integration" icon="robot" color="#10b981">
    Monitor token transfers for automated trading strategies and arbitrage opportunities.
  </Card>
  
  <Card title="Payment Tracking" icon="money-bill-transfer" color="#f59e0b">
    Track payment receipts and confirmations for e-commerce or DeFi applications.
  </Card>
</CardGroup>

## Advanced Example: Token Balance Tracker

Track real-time token balance changes for an account:

```javascript
class TokenBalanceTracker {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.shadowcorp.dev';
    this.balances = new Map(); // tokenContract -> balance
    this.lastCheckedHeight = null;
  }

  async initializeBalances(accountId) {
    console.log(`ðŸ”„ Initializing balances for ${accountId}...`);
    
    // Get recent transfers to establish baseline
    const response = await this.getAccountTransfers(accountId, 100);
    
    // Process transfers to calculate balances
    for (const transfer of response.data) {
      await this.processTransfer(transfer, accountId);
    }
    
    if (response.data.length > 0) {
      this.lastCheckedHeight = response.data[0].block_height;
    }
    
    this.displayBalances();
  }

  async processTransfer(transfer, accountId) {
    const tokenContract = transfer.contract_id;
    const amount = BigInt(transfer.amount);
    
    if (!this.balances.has(tokenContract)) {
      this.balances.set(tokenContract, BigInt(0));
    }
    
    const currentBalance = this.balances.get(tokenContract);
    
    if (transfer.to_account_id === accountId) {
      // Received tokens
      this.balances.set(tokenContract, currentBalance + amount);
      console.log(`ðŸ“¥ Received ${amount} ${tokenContract}`);
    } else if (transfer.from_account_id === accountId) {
      // Sent tokens
      this.balances.set(tokenContract, currentBalance - amount);
      console.log(`ðŸ“¤ Sent ${amount} ${tokenContract}`);
    }
  }

  async monitorTransfers(accountId, intervalMs = 5000) {
    console.log(`ðŸ‘€ Monitoring transfers for ${accountId}...`);
    
    await this.initializeBalances(accountId);
    
    setInterval(async () => {
      await this.checkNewTransfers(accountId);
    }, intervalMs);
  }

  async checkNewTransfers(accountId) {
    try {
      const response = await this.getAccountTransfers(accountId, 50);
      
      // Filter for new transfers
      const newTransfers = response.data.filter(
        t => t.block_height > this.lastCheckedHeight
      );
      
      if (newTransfers.length > 0) {
        console.log(`\nðŸ†• Found ${newTransfers.length} new transfer(s)`);
        
        for (const transfer of newTransfers) {
          await this.processTransfer(transfer, accountId);
        }
        
        this.lastCheckedHeight = Math.max(
          ...newTransfers.map(t => t.block_height)
        );
        
        this.displayBalances();
      }
    } catch (error) {
      console.error('Error checking transfers:', error);
    }
  }

  displayBalances() {
    console.log('\nðŸ’° Current Token Balances:');
    console.log('â”'.repeat(60));
    
    for (const [token, balance] of this.balances.entries()) {
      console.log(`  ${token}: ${balance.toString()}`);
    }
    console.log('â”'.repeat(60));
  }

  async getAccountTransfers(accountId, limit) {
    const response = await fetch(
      `${this.baseUrl}/v1/ft-transfers?account=${accountId}&limit=${limit}`,
      {
        headers: { 'X-API-Key': this.apiKey }
      }
    );
    return await response.json();
  }
}

// Usage
const tracker = new TokenBalanceTracker('YOUR_KEY');
tracker.monitorTransfers('example.near', 5000);
```

## Practical Examples

### Example 1: Calculate Token Volumes

```javascript
async function calculateTokenVolumes(apiKey, accountId, tokenContract) {
  let totalSent = BigInt(0);
  let totalReceived = BigInt(0);
  let transferCount = 0;
  let offset = 0;
  const limit = 100;

  while (true) {
    const response = await fetch(
      `https://api.shadowcorp.dev/v1/ft-transfers?account=${accountId}&limit=${limit}&offset=${offset}`,
      { headers: { 'X-API-Key': apiKey } }
    );
    const data = await response.json();

    for (const transfer of data.data) {
      // Only count transfers for the specified token
      if (transfer.contract_id === tokenContract) {
        const amount = BigInt(transfer.amount);
        
        if (transfer.from_account_id === accountId) {
          totalSent += amount;
        }
        if (transfer.to_account_id === accountId) {
          totalReceived += amount;
        }
        
        transferCount++;
      }
    }

    // Check if we've processed all transfers
    if (offset + limit >= data.total) break;
    offset += limit;
  }

  return {
    token: tokenContract,
    totalSent: totalSent.toString(),
    totalReceived: totalReceived.toString(),
    netFlow: (totalReceived - totalSent).toString(),
    transferCount
  };
}

// Usage
const volumes = await calculateTokenVolumes(
  'YOUR_KEY',
  'example.near',
  'usdt.tether-token.near'
);

console.log('Token Volume Analysis:');
console.log(`  Total Sent: ${volumes.totalSent}`);
console.log(`  Total Received: ${volumes.totalReceived}`);
console.log(`  Net Flow: ${volumes.netFlow}`);
console.log(`  Transfers: ${volumes.transferCount}`);
```

### Example 2: Find Largest Transfers

```javascript
async function findLargestTransfers(apiKey, tokenContract, topN = 10) {
    /** Find the largest transfers for a specific token */
    
    const transfers = [];
    let offset = 0;
    const limit = 100;
    
    // Fetch transfers (limit to first 1000 for performance)
    while (transfers.length < 1000) {
        const response = await fetch(
            `https://api.shadowcorp.dev/v1/ft-transfers?limit=${limit}&offset=${offset}`,
            {
                headers: { 'X-API-Key': apiKey }
            }
        );
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
        
        // Filter by token contract
        const tokenTransfers = data.data.filter(
            t => t.contract_id === tokenContract
        );
        
        transfers.push(...tokenTransfers);
        
        if (offset + limit >= data.total) {
            break;
        }
        offset += limit;
    }
    
    // Sort by amount (use BigInt for accurate sorting of large numbers)
    transfers.sort((a, b) => {
        const amtA = BigInt(a.amount);
        const amtB = BigInt(b.amount);
        return amtA > amtB ? -1 : (amtA < amtB ? 1 : 0);
    });
    
    // Display top N
    console.log(`ðŸ† Top ${topN} Largest Transfers for ${tokenContract}:`);
    console.log("â”".repeat(80));
    
    transfers.slice(0, topN).forEach((transfer, i) => {
        // Parse ISO timestamp
        const timestampStr = transfer.block_timestamp.endsWith('Z') 
            ? transfer.block_timestamp 
            : transfer.block_timestamp + 'Z';
        const timestamp = new Date(timestampStr);
        
        console.log(`\n${i + 1}. Amount: ${transfer.amount}`);
        console.log(`   From: ${transfer.from_account_id}`);
        console.log(`   To: ${transfer.to_account_id}`);
        console.log(`   Time: ${timestamp.toLocaleString()}`);
        if (transfer.memo) {
            console.log(`   Memo: ${transfer.memo.slice(0, 50)}...`);
        }
    });
    
    return transfers.slice(0, topN);
}

// Usage (in Node.js or browser console with async support)
findLargestTransfers('YOUR_KEY', 'usdt.tether-token.near', 10)
    .then(largest => {
        // 'largest' array contains the top N transfers
    })
    .catch(err => console.error(err));
```

### Example 3: Export Transfer History to CSV

```javascript
const fs = require('fs');

async function exportTransfersToCSV(apiKey, accountId, outputFile) {
  const transfers = [];
  let offset = 0;
  const limit = 100;

  console.log('ðŸ“Š Fetching transfer history...');

  // Fetch all transfers
  while (true) {
    const response = await fetch(
      `https://api.shadowcorp.dev/v1/ft-transfers?account=${accountId}&limit=${limit}&offset=${offset}`,
      { headers: { 'X-API-Key': apiKey } }
    );
    const data = await response.json();

    transfers.push(...data.data);
    console.log(`Fetched ${transfers.length} of ${data.total} transfers...`);

    if (offset + limit >= data.total) break;
    offset += limit;
  }

  // Create CSV content
  const headers = [
    'Timestamp',
    'Block Height',
    'Token Contract',
    'From',
    'To',
    'Amount',
    'Direction',
    'Memo',
    'Receipt ID'
  ].join(',');

  const rows = transfers.map(t => {
    const direction = t.from_account_id === accountId ? 'OUT' : 'IN';
    return [
      t.block_timestamp,
      t.block_height,
      t.contract_id,
      t.from_account_id,
      t.to_account_id,
      t.amount,
      direction,
      `"${(t.memo || '').replace(/"/g, '""')}"`, // Escape quotes
      t.receipt_id
    ].join(',');
  });

  const csv = [headers, ...rows].join('\n');

  // Write to file
  fs.writeFileSync(outputFile, csv);
  console.log(`âœ… Exported ${transfers.length} transfers to ${outputFile}`);
}

// Usage
exportTransfersToCSV('YOUR_KEY', 'example.near', 'transfers.csv');
```

## Error Responses

### 400 Bad Request

```json
{
  "error": "Invalid query parameters",
  "code": 400
}
```

<Warning>
  Ensure your `limit` doesn't exceed 100 and `offset` is a non-negative integer.
</Warning>

### 401 Unauthorized

```json
{
  "error": "Missing or invalid API key",
  "code": 401
}
```

### 429 Rate Limit Exceeded

```json
{
  "error": "Rate limit exceeded",
  "code": 429,
  "retry_after": 60
}
```

<Tip>
  If you need to fetch large amounts of transfer data, implement rate limiting and exponential backoff in your application.
</Tip>

## Related Endpoints

<CardGroup cols={2}>
  <Card 
    title="Token Metadata" 
    icon="circle-info" 
    href="/shadow-api/endpoints/tokens"
  >
    Get token details including name, symbol, and decimals
  </Card>
  
  <Card 
    title="Token Holders" 
    icon="users" 
    href="/shadow-api/endpoints/tokens"
  >
    View top holders for any fungible token
  </Card>
  
  <Card 
    title="Account Data" 
    icon="user" 
    href="/shadow-api/endpoints/full-account-data"
  >
    View complete account information including token balances
  </Card>
  
  <Card 
    title="NFT Transfers" 
    icon="image" 
    href="/shadow-api/endpoints/nft-transfers"
  >
    Query non-fungible token transfers
  </Card>
</CardGroup>